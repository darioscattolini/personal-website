---
id: intro
title: "Cómo definir una interfaz para miembros estáticos de clases de
TypeScript"
sidebar_label: "Interfaz para miembros estáticos de clases"
sidebar_position: 1
tags:
  - TypeScript
  - interface
  - static
  - class
---

import TOCInline from '@theme/TOCInline';
import OverflowImage from '@site/src/components/OverflowImage';
import classTranspiledImgUrl from './assets/typescript-class-transpiled-to-ecmascript-5.png';

<TOCInline toc={toc} />

## Qué son los miembros estáticos de una clase

Seguramente ya sabes que una clase puede tener *miembros estáticos* tanto [en
JavaScript](https://es.javascript.info/static-properties-methods) como [en
TypeScript](https://www.typescriptlang.org/docs/handbook/2/classes.html#static-members).
Éstos se definen con la palabra clave `static`. Así como las propiedades y
métodos normales pertenecen o se aplican a cada una de las *instancias* de la
clase, **las propiedades y métodos estáticos no pertenecen a ninguna instancia
particular sino *a la clase* en su conjunto**.

Las propiedades estáticas pueden ser útiles para almacenar constantes y datos de
configuración vinculados a una clase. Los métodos, por su parte, pueden efectuar
operaciones que no son propias de una instancia puntual, como comparar dos
instancias diferentes u operar con ellas.

Podemos analizar esta diferencia con el siguiente ejemplo. Definimos una clase
para construir [vectores bidimensionales](https://es.wikipedia.org/wiki/Vector).
Cada instancia de un vector tiene sus propias propiedades y métodos: `x`, `y` y
`getMagnitude`. A su vez, la clase posee el método estático `sum` para sumar una
cantidad indefinida de vectores bidimensionales.

```ts
class Vector2D {
  constructor(
    public readonly x: number, 
    public readonly y: number
  ) { }

  public static sum(...vectors: Vector2D[]): Vector2D {
    const {x, y} = vectors.reduce((totals, vector) => {
      totals.x += vector.x;
      totals.y += vector.y;
      
      return totals;
    }, {x: 0, y: 0});

    return new this(x, y);
  }

  public getMagnitude(): number {
    return Math.hypot(this.x, this.y);
  }
}
```

Los siguientes usos de esta clase muestran que mientras el método estático `sum`
se invoca desde la clase, el método de instancia `getMagnitude` corresponde a
cada vector particular:

```ts
const vector1 = new Vector2D(3, 4);
const vector2 = new Vector2D(2, -3);
const sumOfVectors = Vector2D.sum(vector1, vector2);
vector1.getMagnitude();                                 // 5
vector2.getMagnitude();                                 // 3.60555...
sumOfVectors.getMagnitude();                            // 5.09901...
```

## Por qué una interfaz para miembros estáticos

Nos planteamos ahora el siguiente problema: debemos **definir una serie de
clases que deben compartir una misma interfaz para sus miembros estáticos**.
Para comprender mejor el problema lo abordaremos con un caso de uso.

Supongamos que estamos desarrollando un juego que incluye una entidad monstruo,
representada mediante la clase madre (o interfaz) `Monster`. Hay distintos tipos
de monstruos, construidos cada uno mediante una clase hija de `Monster` (o que
implementa la interfaz `Monster`): `Orc`, `Zombie`, `Dragon`... Supongamos, por
último, que cada una de estas clases hijas debe implementar una propiedad
estática `maxAmount`, la cual representa la cantidad máxima de monstruos de un
tipo determinado que puede ser instanciada para un escenario particular.

Uno podría sin más implementar la propiedad `maxAmount` en cada una de las
clases hijas:

```ts
class Orc extends Monster {
  static maxAmount = 4;
}

class Zombie extends Monster {
  static maxAmount = 8;
}

// ...
```

Sin embargo, esto tiene una serie de desventajas:

1. El programador debe recordar para cada clase los miembros estáticos que debe
   implementar y sus tipos. Cuantos más miembros estáticos haya que implementar
   más probable se vuelve olvidar alguno o implementarlo incorrectamente.
2. Si `maxAmount`cambia de nombre o de tipo, o se añaden nuevos miembros
   estáticos que todas las clases deben satisfacer, la actualización de las
   clases se realiza una por una al igual que en el punto anterior. El
   programador podría equivocarse al actualizar las clases "manualmente" (podría
   olvidar hacerlo en algunas clases, o realizar incorrectamente alguna
   actualización).
3. Las clases en JavaScript y TypeScript, además de definir tipos, también son
   valores susceptibles de ser manipulados programáticamente. TypeScript no
   permitirá algunas operaciones con variables que almacenan las clases de
   monstruos si los tipos asociados a esas variables no incluyen miembros
   estáticos como `maxAmount`.

Estas desventajas se resumen en el hecho de que **hay una estructura común que
puede ser abstraída de todas estas clases y se está perdiendo la oportunidad de
explotar el potencial de esta abstracción**.

Podemos representar la parte estática de las clases correspondientes a los tipos
de monstruos mediante una interfaz:

```ts
interface MonsterStatic {
  maxAmount: number;
}
```

Lo que necesitamos es una forma de que TypeScript controle que todas las clases
que hereden la clase (o implementen la interfaz) `Monster` contengan como
miembros estáticos los miembros de `MonsterStatic`. Al definir estas clases
queremos poder especificar que su parte estática implementa `MonsterStatic`.
Esto se expresaría así en pseudo-código:

```ts
class Orc extends Monster y cuya parte estática implementa MonsterStatic {
  // ...
}
```

De aquí en más, para abstraernos de nuestro caso de uso, **nos referiremos a
`MonsterStatic` como *interfaz estática* y a las clases cuya parte estática
es representada por dicha interfaz como *clases representadas***.

Esta posibilidad de representar los miembros estáticos de varias clases mediante
una misma interfaz estática elimina las anteriores desventajas:

1. El programador ya no debe recordar para cada clase representada los miembros
   estáticos que debe implementar y sus tipos, sino que **debe limitarse a
   especificar que la parte estática de dichas clases implementa una interfaz
   estática. TypeScript se encargará de reclamar que se implementen los miembros
   contenidos en ella**.
2. **Si se produce una modificación en la interfaz estática, TypeScript exigirá
   actualizar los miembros de todas las clases representadas que la
   implementan**. Cualquier inconsistencia será detectada inmediatamente por el
   compilador.
3. **La interfaz estática puede ser usada para especificar el tipo de las
   variables que se usen para referir a las clases representadas**. Esto
   facilita el uso de esas clases como valores y su manipulación programática.
   Por ejemplo:

  ```ts
  function createMonsters(monsterClasses: MonsterStatic[]): Monster[] {
    const monsters: Monster[] = [];

    for (const Monster of monsterClasses) {
      for (let i = 0; i < Monster.maxAmount; i++) {
        monsters.push(new Monster());
      }
    }

    return monsters;
  }
  ```

:::info Las clases en cuanto objetos, y sus tipos

Las clases en JavaScript son [objetos de primera
clase](https://en.wikipedia.org/wiki/First-class_citizen), pueden ser valores de
variables y ser representadas por tipos en TypeScript. Si transpilamos una clase
de TypeScript a EcmaScript 5 podemos comprender mejor en qué consisten las
clases en cuanto objetos:

<OverflowImage
  src={classTranspiledImgUrl}
  alt={'TypeScript class transpiled to ECMAScript 5'}
  minWidth={600}
  maxWidth={900}
/>

Como se puede ver en la porción de código rodeada con un recuadro, una clase en
última instancia es una [función
constructora](https://es.javascript.info/constructor-new) como `Example`. Sus
propiedades de instancia se asignan como propiedades de `this` dentro de la
función constructora, sea que sus valores provengan de parámetros o se asignen
al declarar la propiedad. Los métodos de instancia, en cambio, se añaden al
objeto `prototype` de la función constructora. Las funciones en JavaScript son
objetos, y por ende se les puede añadir nuevas propiedades. Las propiedades y
métodos estáticos de la clase no son otra cosa que propiedades añadidas a la
función constructora en tanto objeto.

¿Cuál sería, entonces, el tipo de un objeto como `Example`? En TypeScript toda
clase es a la vez un valor y un tipo. Al definir una clase no sólo estamos
creando un valor, una función constructora, sino también generando una interfaz
que describe la forma de las instancias creadas por dicha función. Esto es lo
que permite usar el nombre de una clase para tipar variables en declaraciones
como `const example: Example = ...`. Sin embargo, aquí no nos estamos
preguntando por el tipo *de las instancias* de `Example`, sino por el tipo de
`Example` *en cuanto objeto*.

TypeScript nos ofrece una forma directa de referirnos a ese tipo sin tener que
construirlo explícitamente: `typeof Example`. Más adelante comprobaremos su
utilidad. 

También podemos construir explícitamente ese tipo: se trata de una función
constructora con determinadas propiedades añadidas. Lo que antes hemos definido
como una interfaz estática es una interfaz que representa estas propiedades
añadidas a la función constructora. La función constructora misma es tipada
mediante un [distintivo de
constructor](https://www.typescriptlang.org/docs/handbook/2/functions.html#construct-signatures).
El tipo explícito de una clase entonces es un distintivo de constructor más los
tipos de los miembros estáticos. En el caso de `Example` se vería así:

```ts
type TypeOfExample = {
  // distintivo de constructor
  new (parameter: string): {
    instanceProp1: string,
    instanceProp2: string,
    instanceMethod(): string
  };

  // interfaz estática
  staticProp: string;
  staticMethod(): string;
};
```

Naturalmente, este tipo no representa la interfaz completa de `Example`, ya que
los objetos de JavaScript son creados con miembros adicionales a los que se
explicitan en su definición. Sin embargo, aquí no nos interesa tipar esas
funcionalidades "de fábrica".

:::

Hemos definido qué es y para qué nos sirve una interfaz estática. Planteado así
el problema, primero mostraremos distintas estrategias para construir y aplicar
la interfaz `MonsterStatic`, y al final del artículo presentaremos un caso de
uso más realista.

## Cinco abordajes del problema

Ensayaremos ahora cinco intentos para especificar que un grupo de clases
implementa una interfaz estática. Los primeros dos representan enfoques
intuitivos que no llegan a cumplir con nuestros requerimientos o fracasan por
limitaciones en la sintaxis de TypeScript. Los otros tres intentos representan
soluciones correctas pero con distintas desventajas.

### 1. Interfaz estática implementada en una clase madre

**Una forma intuitiva de abstraer funcionalidad común entre diferentes clases es
utilizando el mecanismo de *herencia***, presente tanto [en
JavaScript](https://es.javascript.info/class-inheritance) como [en
TypeScript](https://www.typescriptlang.org/docs/handbook/2/classes.html#extends-clauses).
Podríamos intentar implementar `MonsterStatic` en la clase madre `Monster`, y
hacer que las clases representadas hereden la interfaz estática de esta clase
madre.

**JavaScript y TypeScript permiten la herencia de propiedades y métodos
estáticos**. Su mecanismo es análogo a la herencia de miembros de instancia: si
no están implementados para la clase hija, se los busca en la clase madre. Por
ejemplo:

```ts
class Monster {
  static maxAmount = 5;

  constructor(
    public readonly type: string,
    public damage: number,
    public hitPoints: number
  ) { }
  
  public attack(target: Character): void {
    // ...
  }
}

class Orc extends Monster {
  constructor() {
    super('Orc', 3, 10);
  }
}

class Zombie extends Monster {
  static maxAmount = 8;

  constructor() {
    // ...
  }
}

Orc.maxAmount;          // 5
Zombie.maxAmount;       // 8
```

Sin embargo, esta forma de herencia no nos sirve para nuestro caso de uso, ya
que el valor de la propiedad `maxAmount` es especial para cada una de las clases
representadas, por lo que no puede especificarse en la clase madre. Esta
solución **sólo es útil en casos donde no requerimos que las clases hijas
implementen miembros estáticos diferentes a los de la clase madre, p. ej. si
requerimos un método estático no polimórfico (con una única implementación)**.
Por ejemplo, retomando la clase para los vectores definida en la primera
sección, podemos construir clases hijas para entidades físicas como la velocidad
o la fuerza sin reformular el método `sum`, que puede ser heredado.

Uno podría intentar mantener este esquema de solución **recurriendo a las
*clases abstractas*, que no existen en JavaScript pero [sí en
TypeScript](https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes-and-members)**.
Así, `Monster` se definiría como una clase abstracta, que contendría a
`maxAmount` como propiedad estática abstracta. Como ocurre con los miembros de
instancia abstractos, cada clase que herede de `Monster` debería contener una
implementación de `maxAmount`, cumpliendo el objetivo que nos proponemos.

Sin embargo, por el momento **TypeScript no permite que los miembros estáticos
de una clase sean abstractos**. [En el repositorio de TypeScript hay una
discusión abierta en torno a la posibilidad de incluir esta funcionalidad dentro
del lenguaje](https://github.com/microsoft/TypeScript/issues/34516), pero aun no
parece estar en vías de resolución.

### 2. Interfaz estática incluida en una interfaz implementada por las clases representadas

[Las *interfaces* son otro tipo de abstracción que pueden representar elementos
comunes a diversas clases y
objetos](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces).
A diferencia de una clase madre, que es un tipo y un valor, una interfaz de
TypeScript es sólo un tipo. En consecuencia, **no puede implementar ninguna
funcionalidad: no puede establecer ningún valor o implementación para sus
miembros, sino sólo especificar *sus tipos***. Esta especificación representa un
"contrato" que las diversas clases que lo implementan deben cumplir: los nombres
y los tipos que deben tener determinados miembros de dichas clases. Otras partes
del código luego pueden contentarse con saber que están interactuando con una
entidad que implementa dicho contrato (p. ej., saber que pueden llamar a
determinado método y obtener determinado tipo de valor) sin acoplarse con
ninguna implementación particular del mismo.

Podemos intentar definir una interfaz a ser implementada por las clases
representadas, incluyendo en ella nuestra interfaz estática. El resultado
quedaría así:

```ts
interface Monster {
  static maxAmount: number;
  readonly type: string;
  damage: number;
  hitPoints: number;
  attack(target: Character): void;
}

class Orc implements Monster {
  // ...
}
```

Sin embargo, como ocurre con los miembros estáticos abstractos, **TypeScript
tampoco permite la especificación de propiedades estáticas dentro de una
interfaz**. La razón es que esto introduciría una ambigüedad en el concepto de
interfaz. **Las interfaces especifican la forma *de las instancias* de las
clases que las implementan**: las propiedades y métodos contenidos en las
instancias, y sus tipos. Si las mismas interfaces se usaran también para
especificar las propiedades y métodos *de las propias clases* tomadas como
objetos podrían surgir usos extraños. Por ejemplo, se podría definir interfaces
exclusivamente estáticas que podrían ser un tipo válido para cualquier objeto,
ya que no hay requisitos que deban satisfacer los miembros de las instancias:

```ts
interface Monster {
  static maxAmount: number;
}

const orc: Monster = {};    // Esto sería válido
```

Una forma de resolver esta ambiguedad que los miembros de `Monster` **se
desdoblen en dos interfaces diferentes: por un lado el contrato que deben
cumplir las clases en su parte estática, y por otro el que deben cumplir sus
instancias**. Esto requeriría una sintaxis especial para especificar en qué
casos estamos queriendo decir que una clase implementa una interfaz estática:
podemos seguir diciendo `implements SomeInterface` cuando la interfaz representa
a las instancias, pero tendremos que decir algo como `implements static
SomeInterface` cuando la interfaz representa la parte estática de la propia
clase. Nuestro caso de uso se vería entonces así:

```ts
interface Monster {
  readonly type: string;
  damage: number;
  hitPoints: number;
  attack(target: Character): void;
}

interface MonsterStatic {
  maxAmount: number;
}

class Orc implements Monster, static MonsterStatic {
  // ...
}
```

Esto elimina cualquier ambigüedadS: se utilizaría la interfaz `Monster` para
representar las instancias de las clases y `MonsterStatic` para representar las
clases mismas en cuanto valores. Sin embargo, **por el momento esta sintaxis no
está incluida en TypeScript**, [aunque su incorporación está en
discusión](https://github.com/microsoft/TypeScript/issues/33892).

### 3. Definición de las clases representadas mediante expresiones de clase tipadas con la interfaz estática

A diferencia de otros lengujes como Java, **en JavaScript las clases son valores
como cualquier otro**. No sólo ofrecen una sintaxis especial para construir
objetos, sino que ellas mismas son objetos: pueden ser valores de variables, y
pueden ser representadas por tipos en TypeScript. Esto nos permite [definir una
clase mediante una *expresión* que representa dicho valor, en lugar del método
tradicional de la
declaración](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class):

```ts
// declaración de clase
class Orc {
  // ...
}

// expresión de clase
const Orc = class {
  // ...
};
```

En el segundo caso del ejemplo anterior `class { }` constituye una expresión,
una porción de código que representa un valor (una función constructora), el
cual es asignado a la variable `Orc`. En las expresiones de clase también es
posible especificar una relación de herencia, y la implementación de interfaces
en el caso de TypeScript:

```ts
const Orc = class extends Monster {
  // ...
};

const Orc = class implements Monster {
  // ...
};
```

Esta forma de definir una clase puede ser usada en TypeScript para **requerir
que la clase definida sea de un tipo determinado utilizando una [*anotación de
tipo*](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-annotations-on-variables)**.
Dicho tipo es **especificado al declarar la variable** en la que se almacenará
la clase, pudiendo ser una interfaz que establezca los requerimientos que debe
satisfacer la parte estática de la clase.

Partiendo de las interfaces desdobladas definidas anteriormente, nuestro caso de
uso ahora se vería así:

```ts
const Orc: MonsterStatic = class implements Monster {
  public static maxAmount = 5;

  public readonly type = 'Orc';
  public damage = 3;
  public hitPoints = 10;

  public attack (target: Character): void {
    // ...
  };
};
```

También podemos usar una clase en lugar de la interfaz `Monster`:

```ts
class Monster {
  constructor(
    public readonly type: string,
    public damage: number,
    public hitPoints: number
  ) { }
  
  public attack (target: Character): void {
    // ...
  };
}

const Orc: MonsterStatic = class extends Monster {
  public static maxAmount = 5;

  constructor() {
    super('Orc', 3, 10);
  }
};
```

Resta un último detalle: la interfaz `MonsterStatic` **debe representar también
que sus instancias, en tanto clases, son funciones constructoras**. De lo
contrario ciertos usos de estos valores no estarían permitidos (por ejemplo, la
función `createMonsters` definida en la segunda sección), ya que TypeScript no
tendría cómo saber que los objetos del tipo `MonsterStatic` son clases que
pueden crear objetos con `new`. Es preciso **añadir a la interfaz lo que en
TypeScript se conoce como [*construct signature* o *distintivo de
constructor*](https://www.typescriptlang.org/docs/handbook/2/functions.html#construct-signatures)**.

```ts
interface MonsterStatic {
  maxAmount: number;
  new(...args: any[]): Monster;     // distintivo de constructor
}
```

Nótese que si `Monster` es una interfaz en lugar de una clase **podemos
prescindir de `implements Monster`** en las expresiones de clase. TypeScript
infiere del distintivo de constructor que las instancias de las clases de tipo
`MonsterStatic` serán de tipo `Monster`, por lo que especificarlo nuevamente en
la expresión de clase es redundante:

```ts
const Orc: MonsterStatic = class {
  // ...
}
```

Nuestras clases representadas podrían tener constructores privados y **utilizar
métodos *factory* estáticos para instanciar objetos**. En ese caso la interfaz
estática no deberá contener un distintivo de constructor, sino el tipo de los
métodos *factory* :

```ts
interface MonsterStatic {
  maxAmount: number;
  create(): Monster;
}

const Orc: MonsterStatic = class implements Monster {
  public static maxAmount = 5;
  
  // ...
  
  public static create() {
    return new this();
  };

  // ...
};
```

:::info Valor de `this` en métodos estáticos - Expresiones de clase nombradas

El método `create()` crea instancias de `Orc` mediante la expresión `new
this()`. No usamos `new Orc()` porque esto no es una expresión válida para
TypeScript: `Orc` es de tipo `MonsterStatic`, que ahora no incluye el distintivo
de constructor. La palabra clave **`this` en métodos estáticos no refiere a la
instancia sino *a la clase* desde la que se invoca el método**. Por ello puede
usarse aquí para referir a la clase anónima definida mediante una expresión de
clase. Normalmente `this` se usaría en un método estático para invocar otras
propiedades o métodos estáticos de la misma clase.

Una alternativa al uso de `this` es **que la expresión de clase no sea anónima,
añadiendo algún nombre luego de la palabra clave `class`**. Este identificador
**será una variable *local***, válida sólo dentro del cuerpo de la propia clase.
Podría repetirse el identificador `Orc`, que ya no será la variable de tipo
`MonsterStatic` declarada con `const` sino una variable local que refiere a lo
mismo que a `this` dentro de la clase:

```ts
const Orc: MonsterStatic = class Orc implements Monster {
  // ...

  public create() {
    return new Orc();
  };

  // ...
};
```

:::

Esta solución es la primera que cumple con nuestros requerimientos iniciales.
Sin embargo, tiene una serie de limitaciones.

En primer lugar, veamos lo que ocurriría **si las clases representadas tuvieran
que ser abstractas**. Primero deberíamos modificar el distintivo de constructor
en `MonsterStatic`, ya que las clases abstractas no pueden crear instancias con
`new`. Esto se puede hacer porque [recientemente TypeScript introdujo la
posibilidad de **especificar distintivos de constructor
abstractos**](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#abstract-construct-signatures).
Dado que las interfaces no admiten miembros abstractos, el distintivo de
constructor y los miembros estáticos se deben incluir en tipos diferentes que
son reunidos [mediante una
*intersección*](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types):

```ts
type AbstractConstructor<T> = abstract new (...args: any[]) => T;

type MonsterStatic = { maxAmount: number; } 
  & AbstractConstructor<Monster>;
```

Resuelto esto, nos topamos ahora con que **TypeScript no permite la definición
de clases abstractas mediante expresiones de clase**. Enunciados como el
siguiente producen un error, ya que `abstract` no es interpretado como una
palabra clave sino como un identificador, como el nombre de una variable que en
este caso es inexistente:

```ts
const Orc: MonsterStatic = abstract class {   // Cannot find name 'abstract'
  // ...
};
```

Un pequeño rodeo nos permite sortear este problema, aunque el resultado es muy
poco elegante:

```ts
abstract class _Orc {
  // ...
};

const Orc: MonsterStatic = _Orc;
```

Veamos un segundo problema. Una consecuencia de caracterizar la constante `Orc`
con el tipo `MonsterStatic` es que para TypeScript tanto el objeto devuelto por
`new Orc()` como por `Orc.create()` será genéricamente de tipo `Monster` (y lo
mismo ocurrirá para las clases `Zombie`, `Dragon`, etc.). Si hubieramos usado
una declaración de clase o la constante `Orc` sin tipar, el tipo sería
específicamente `Orc` (y `Zombie`, `Dragon`... para el resto de las clases). Es
decir, **con esta solución TypeScript no podrá discriminar que las instancias
son de clases distintas**. Esto se debe a que el distintivo de constructor
contenido en `MonsterStatic` especifica de manera genérica que el constructor
devuelve un objeto `Monster`.

Esta consecuencia es problemática si las clases representadas además de incluir
los miembros contenidos en `Monster` tienen propiedades y métodos de instancias
específicos. Por ejemplo, si `Orc` incluyera una habilidad especial `enrage()`,
ésta no podría ser invocada porque no forma parte de la interfaz `Monster`:

```ts
const Orc: MonsterStatic = class {
  // ...

  public enrage(): void {
    // ...
  }
};

const orc = new Orc();    // variable de tipo Monster
orc.enrage();             // inválido: la propiedad enrage no existe en Monster
```

En tercer lugar, veamos qué ocurre **si las clases que debemos definir son tipos
parametrizados o *genéricos***. Supongamos que hay dos tipos de ataque que puede
ejercer un monstruo, cuerpo a cuerpo y a distancia, con sus correspondientes
tipos de armas. Podemos definir el tipo `Weapon` como un genérico cuyo parámetro
corresponde al tipo de arma, y añadir a la interfaz `Monster` un método para
equipar armas que utilice el mismo tipo de parámetro:

```ts
type AttackType = 'ranged' | 'melee';

interface Weapon<T extends AttackType> {
  readonly type: T;
  // ...
}

interface Monster<T extends AttackType> {
  // ...
  equip(weapon: Weapon<T>): void;
}
```

Esta modificación no es compatible con la actual solución porque en una
declaración de variable **no tenemos dónde definir el nombre y el tipo del
parámetro genérico**. Si intentamos hacerlo de la siguiente manera se produce un
error:

```ts
const Orc: MonsterStatic<T extends AttackType> = class {    // Cannot find name 'T'
  // ...
};
```

**Lo que necesitamos es una solución que nos permita emplear *declaraciones de
clase***, con lo cual podremos definir nuestras clases representadas de la
siguiente forma:

```ts
class Orc<T extends AttackType> //...
```

Esta solución nos permitiría definir parámetros genéricos, y presumiblemente
resolvería también el problema de los miembros de instancia específicos como
`enrage`, ya que las instancias creadas con `new Orc()` ahora serían reconocidas
como instancias de `Orc` y no meramente de `Monster`.

### 4. Interfaz estática incluida en un tipo construido a partir de `InstanceType` e implementado por las clases representadas

La solución que mostraremos ahora es menos intuitiva que las anteriores, ya que
ya que explota las posibilidades ofrecidas por TypeScript de una forma bastante
más artificiosa. La clave de esta solución es retomar la estrategia de nuestro
segundo intento fallido: **construir un tipo `Monster` que pueda ser empleado en
una expresión de tipo `class Orc implements Monster` y que incluya los
requerimientos de `MonsterStatic`**.

Incorporaremos el último requerimiento añadido en la sección anterior: nuestra
solución debe poder aplicarse también a tipos parametrizados. Renombraremos
`Monster` como `MonsterInstance` para distinguir la interfaz que representa
nuestras instancias del tipo `Monster` que estamos intentando construir.
Nuestras interfaces desdobladas son entonces las siguientes:

```ts
interface MonsterInstance<T extends AttackType> {
  readonly type: string;
  damage: number;
  hitPoints: number;
  attack (target: Character): void;
  equip(weapon: Weapon<T>): void;
}

interface MonsterStatic<T extends AttackType> {
  new (...args: any[]): MonsterInstance<T>;
  maxAmount: number;
}
```

El tipo **`Monster` debe explicitar de alguna manera que los objetos que
representa son instancias de `MonsterStatic`**. Para ello [**usaremos el tipo
`InstanceType`**, uno de los tipos predefinidos por
TypeScript](https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype).
Se trata de un tipo parametrizado, cuyo parámetro debe ser cualquier tipo que
contenga un distintivo de constructor, y se usa para representar el tipo de la
instancia generada por dicho constructor. Por ejemplo:

```ts
class _Monster {
  // ...
}

type Monster = InstanceType<typeof _Monster>;

// el tipo declarado con la anotación y el de la instancia de _Monster coinciden
const monster: Monster = new _Monster();
```

En nuestro caso el tipo con distintivo de constructor es `MonsterStatic`.
Nuestra estrategia será entonces la siguiente:

```ts
type Monster<T extends AttackType> = InstanceType<MonsterStatic<T>>;

class Orc<T extends AttackType> implements Monster<T> {
  // ...
}
```

Esto requerirá que `Orc` contenga todos los miembros de instancia contenidos en
`MonsterInstance`. Sin embargo, aún no requiere la inclusión de la propiedad
estática `maxAmount`. Esto tiene lógica porque `implements SomeInterface` sólo
impone requerimientos sobre la forma que tendrán *las instancias* de las clases
definidas de este modo.

El truco que emplearemos explota la posibilidad de usar los parámetros de un
tipo genérico para imponer requerimientos adicionales. Así, además del parámetro
de tipo `AttackType`, **incluiremos en `Monster` otro parámetro que extienda
`MonsterStatic`**. Esto nos permite reformular `Monster` de la siguiente manera:

```ts
type Monster<T extends AttackType, S extends MonsterStatic<T>> = InstanceType<S>;
```

Para comprobar la utilidad de esto hay que ver cómo usamos esta versión
modificada de `Monster` en la definición de nuestras clases representadas. ¿Qué
tipo se puede emplear en lugar de `S`? Aquí emplearemos nuestro segundo truco:
**en los parámetros de `Monster` podemos hacer referencia a la propia clase
`Orc` que estamos declarando**. Si en el lugar de `S` ponemos `typeof Orc`
TypeScript hará su magia: dado que `S` debe extender `MonsterStatic`, `Orc` no
sólo debe incluir un constructor de instancias que satisfagan `MonsterInstance`,
sino también la propiedad `maxAmount` incluida en `MonsterStatic`:

```ts
class Orc<T extends AttackType> implements Monster<T, typeof Orc> {
  // ...
}
```

Así, en lugar de forzar los requerimientos de `MonsterStatic` a través de la
declaración de variable `const Orc: MonsterStatic`, lo estamos haciendo al
incluir `typeof Orc` como parámetro de un genérico que debe cumplir con `S
extends MonsterStatic`.

Esta solución **permite a TypeScript reconocer miembros especiales de algunas
clases representadas**. Supongamos que queremos agregar la habilidad especial
`enrage()` a `Orc`. Los problemas que encontramos con la anterior solución ya no
aparecen:

```ts
class Orc<T extends AttackType> implements Monster<T, typeof Orc> {
  // ...

  public enrage(): void {
    // ...
  }
};

const orc = new Orc<'melee'>();    // variable de tipo Orc
orc.enrage();                      // enunciado válido
```

**Otra ventaja de esta solución es que es generalizable**. Supongamos que no
sólo los monstruos son clases representadas que deben representar una interfaz
estática, sino también las armas, los items del inventario, etc., cada tipo de
entidad con su respectiva interfaz estática. En lugar de repetir este patrón
construyendo un tipo `Monster`, `Weapon`, etc., a partir de su respectiva
interfaz estática, podemos generalizarlo: **construir un mismo tipo genérico
`StaticImplements` que recibe como argumento la interfaz estática que le
corresponde en cada caso de uso**:

```ts
// distintivo de constructor que abarca a clases abstractas y concretas
// las interfaces estáticas deberán extender este tipo
type Constructor = abstract new (...args: any[]) => any;

type StaticImplements<
  StaticInterface extends Constructor,    // nuevo parámetro para interfaz estática
  TypeOfClass extends StaticInterface
> = InstanceType<TypeOfClass>;

interface MonsterStatic<T extends AttackType> {
  // ...
}

interface WeaponStatic<T extends AttackType> {
  // ...
}

interface ItemStatic {
  // ...
}

class Orc<T extends AttackType> 
  implements StaticImplements<MonsterStatic<T>, typeof Orc> {
    // ...
  }

class Sword<T extends AttackType> 
  implements StaticImplements<WeaponStatic<T>, typeof Sword> {
    // ...
  }

class Book implements StaticImplements<ItemStatic, typeof Book> {
  // ...
}
```

Esta solución generalizada **nos permite simplificar los nombres de las
interfaces de instancia**: `MonsterInstance` puede volver a llamarse `Monster`
sin riesgos de confusión.

Si bien esta solución cumple con todos nuestros requisitos, **las definiciones
de las clases representadas se vuelven demasiado extensas y rebuscadas**.
Alguien que vea a simple vista un código escrito de esa forma seguramente no
entendería a primera vista el porqué de estos constructos verbosos y
artificiosos, lo que requeriría comentar el código de forma clara.

OTRO PROBLEMA: CLASES SIN CONSTRUCTORES (ABSTRACTAS O CON CONSTRUCTOR PRIVADO)

Es por ello que en la siguiente sección ofrecemos otra solución más concisa y
elegante.

### 5. Asignación de la interfaz estática mediante un decorador

Los *decoradores* son una funcionalidad cuya inclusión en JavaScript está en
discusión y en TypeScript es de carácter experimental (sujeta a futuros cambios,
probablemente en función de cómo se termine de implementar en JavaScript). Éstos
[*proveen una forma de añadir anotaciones y una sintaxis de metaprogramación a
las declaraciones de clases y sus
miembros*](https://www.typescriptlang.org/docs/handbook/decorators.html). Los
decoradores en esencia son funciones que reciben como argumento la clase a la
que se aplican y la transforman de alguna manera.

En nuestro caso no queremos realizar ninguna transformación de las clases
representadas, sino lograr que TypeScript fuerce que implementen una interfaz
estática. Esto requiere en primer lugar que la función que usemos como decorador
no devuelva nada, ya que si no tiene un `return` devuelve la misma clase que
recibe como argumento. En segundo lugar, es necesario tipar el parámetro de la
función con nuestra interfaz `MonsterStatic`, para que el decorador requiera que
las clases a la que se aplica implementen dicha interfaz. Nuestro caso de uso se
vería así:

```ts
interface Monster<T extends AttackType> {
  readonly type: string;
  damage: number;
  hitPoints: number;
  attack (target: Character): void;
  equip(weapon: Weapon<T>): void;
}

interface MonsterStatic<T extends AttackType> {
  new (...args: any[]): Monster<T>;
  maxAmount: number;
}

function MonsterClass<T extends AttackType>(monsterClass: MonsterStatic<T>) { }    // decorador

@MonsterClass       // aplicación del decorador
class Orc<T extends AttackType> {
  // ...

  enrage() {
    // ...
  }
}

@MonsterClass
class Zombie<T extends AttackType> {
  // ...
}

// ...
```

Definiendo `Orc`, `Zombie`... de esta manera el código no se compilará hasta que
dichas clases contengan los miembros estáticos de `MonsterStatic`. A su vez,
como el distintivo de constructor de esta interfaz devuelve un objeto de tipo
`Monster`, TypeScript también exigirá que las clases implementen los miembros de
instancia contenidos en dicha interfaz.

Estas clases en tanto objetos son reconocidas como pertenecientes al tipo
`MonsterStatic`, lo que facilita su uso como valores:

```ts
const monsterClasses: MonsterStatic<AttackType>[] = [
  Orc, Zombie, // ...
];                                          // este enunciado es válido
```

Finalmente, las instancias de estas clases son reconocidas como instancias de
`Orc`, `Zombie` y cada clase respectiva, y no del tipo más general `Monster`.
Esto implica que los miembros de dichas clases que no son parte de `Monster`
también son reconocidos por el compilador:

```ts
const orc = new Orc();
orc.enrage();                               // este enunciado es válido
```

Esta solución cumple entonces con todos nuestros requerimientos. Al igual que la
solución anterior, también es generalizable. Si queremos aplicar este mismo
patrón a distintos conjuntos de clases, en lugar de construir diferentes
decoradores podemos usar una misma función *factory* para producirlos a todos,
siempre que se le pase la interfaz estática correspondiente como argumento
genérico:

```ts
function StaticImplements<T>() {      // factory de decoradores
  return (constructor: T) => {}
}

interface WeaponStatic<T extends AttackType> {
  // ...
}

@StaticImplements<MonsterStatic<AttackType>>()
class Orc {
  // ...
}

@StaticImplements<WeaponStatic<AttackType>>()
class Sword {
  // ...
}
```

La desventaja de esta solución es que depende de una sintaxis experimental que
podría quedar obsoleta ante una actualización de TypeScript. Para poder usarla
es necesario habilitar la opción `experimentalDecorators: true` en
`tsconfig.json`.

## Un caso de uso más realista

El caso de uso que hemos utilizado hasta ahora nos ha facilitado presentar el
problema de una forma simple e ir complejizándolo de manera sucesiva a medida
que íbamos presentando las distintas soluciones. Sin embargo, no me parece un
ejemplo demasiado realista. En lugar de regular la creación de instancias de
monstruos mediante propiedades estáticas contenidas en sus propias clases,
parece más lógico que haya una clase separada que contenga las instrucciones
para poblar los diferentes escenarios del juego.

Veamos entonces un caso de uso más realista. Supongamos que estamos
desarrollando una tienda online que debe mostrar listas ordenadas de diferentes
entidades. Por ejemplo, rankings de clientes, empleados y productos. Estas
entidades serán representadas en la aplicación mediante las clases `Customer`,
`Employee` y `Article`. Cada una de estas clases puede admitir un método de
ordenamiento diferente para sus respectivas instancias: los clientes serán
ordenados en función de la cantidad de productos comprados, los empleados en
función de su antigüedad y los artículos en función de su popularidad.

Cada clase tendrá las propiedades y métodos correspondientes a su tipo. Por
ejemplo, podrían implementar las siguientes interfaces:

```ts
interface Customer {
  name: string;
  email: string;
  purchases: number;
}

interface Employee {
  name: string;
  employeeNumber: string;
  joiningDate: Date;
}

interface Article {
  name: string;
  ean: string;
  purchases: number;
}
```

Cada clase además implementará su propio método `sort` para ordenar sus
respectivas instancias. Este método no compete a ninguna instancia particular,
sino que ordena las instancias que le son pasadas como parámetros. Lo lógico es
implementarlo como miembro estático de cada clase, requiriendo que la parte
estática de éstas implemente la siguiente interfaz:

```ts
interface Sorting<T> {
  sort: (unsorted: T[]) => T[];
}
```

Lo que debemos hacer entonces es reemplazar las interfaces `Customer`,
`Employee` y `Article` por clases que implementen la interfaz estática
`Sorting`. Descartamos la primera solución funcional (el tercer intento), ya que
no admite que las interfaces estáticas sean tipos parametrizados como `Sorting`.
Nos quedan las soluciones que usan `InstanceType` y decoradores.

### Solución empleando `InstanceType`

Esta solución requiere que incluyamos en `Sorting` un distintivo de constructor
para poder utilizarlo como argumento de `InstanceType`. El resultado es el
siguiente:

```ts
interface Sorting<T> {
  new (...args: any[]): T
  sort: (unsorted: T[]) => T[];
}

type Sortable<T, S extends Sorting<T>> = InstanceType<S>;
```

El primer parámetro `T` nos permite introducir un argumento de genérico en
`Sorting` para especificar que la clase ordena elementos del tipo `T`, y a la
vez usar el mismo argumento en el distintivo de constructor para especificar que
la clase crea instancias del tipo `T`.

Luego podemos construir nuestras clases de la siguiente manera:

```ts
class Customer implements SortableClass<Customer, typeof Customer>{
  constructor(
    public name: string,
    public email: string,
    public purchases: number
  ) {}

  public static sort(unsorted: Customer[]): Customer[] {
    // ...
  }
}

class Employee implements SortableClass<Employee, typeof Employee>{
  constructor(
    public name: string,
    public employeeNumber: string,
    public joiningDate: Date
  ) {}

  public static sort(unsorted: Employee[]): Employee[] {
    // ...
  }
}

class Article implements SortableClass<Article, typeof Article>{
  constructor(
    public name: string,
    public ean: string,
    public purchases: number
  ) {}

  public static sort(unsorted: Article[]): Article[] {
    // ...
  }
}
```

Esta solución cumple con todos nuestros requerimientos. Por ejemplo, podemos
construir un componente `SortedList` para mostrar como un elemento html de tipo
`<ol>` nuestras listas de elementos ordenados, haciendo uso de los tipos antes
desarrollados. El método `render` del componente devuelve una lista html con la
cantidad de elementos especificados en su argumento. Aquí optamos por construir
el componente genérico como una clase abstracta y usar distintas clases hijas
para cada tipo de lista:

```ts
abstract class SortedList<T extends Sorting<any>> {
  protected abstract sortingClass: T;

  constructor(
    private items: InstanceType<T>[]
  ) {}

  public render(amount: number): string {
    amount = amount > this.items.length ? this.items.length : amount;
    const sorted = this.sortingClass.sort(this.items);
    let list = '';

    for (let i = 0; i < amount; i++) {
      list += `<li>${sorted[i]}</li>`;
    }
    
    return `<ol>${list}</ol>`
  }
}

class CustomerList extends SortedList<typeof Customer> {
  protected sortingClass = Customer;
}

class EmployeeList extends SortedList<typeof Employee> {
  protected sortingClass = Employee;
}

class ArticleList extends SortedList<typeof Article> {
  protected sortingClass = Article;
}
```

Aquí se puede ver el ejemplo completo en funcionamiento. Nótese que hemos
abstraido una clase `Named` de nuestras clases representadas para implementar el
método `toString`, ya que éste que es utilizado implícitamente por `render` en
`SortedList`. También hemos implementado el método `sort` en dichas clases según
los criterios de ordenamiento antes mencionados.

<iframe class="stackblitz"
  src="https://stackblitz.com/edit/typescript-hr3gpq?ctl=1&embed=1&file=index.ts&hideExplorer=1&hideNavigation=1&theme=dark"
></iframe>

### Solución empleando un decorador

## Referencias

Este tópico ha sido discutido en diversos hilos de discusión en el repositorio
de TypeScript. Las discusiones han girado en torno a la necesidad de hacer
modificaciones a TypeScript para que haya una sintaxis sencilla para este tipo
de casos de uso. Allí se pueden encontrar diversos ejemplos de uso de interfaces
estáticas, así como soluciones alternativas y propuestas para incorporar nuevas
funcionalidades a TypeScript:

* [#1263 - Introduce a way to enforce a static
  contract](https://github.com/microsoft/TypeScript/issues/1263)
* [#13462 - Add support Interfaces to define static
  methods](https://github.com/microsoft/TypeScript/issues/13462)
* [#14600 - Suggestion: Add abstract static methods in classes and static
  methods in interfaces
  methods](https://github.com/microsoft/TypeScript/issues/14600)
* [#17545 - Why doesn't TypeScript provide a way to implement an interface on
  the static side?](https://github.com/microsoft/TypeScript/issues/17545)
* [#33892 - Allow specifying interface implements clauses for the static side of
  classes](https://github.com/microsoft/TypeScript/issues/33892)
* [#34516 - static abstract methods and
  properties](https://github.com/microsoft/TypeScript/issues/34516)
